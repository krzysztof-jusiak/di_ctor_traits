#!/usr/bin/env python

#
# Copyright (c) 2014 Krzysztof Jusiak (krzysztof at jusiak dot net)
#
# Distributed under the Boost Software License, Version 1.0.
# (See accompanying file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
#

import os
import sys
from optparse import OptionParser
from clang.cindex import Index
from clang.cindex import TranslationUnit
from clang.cindex import Cursor
from clang.cindex import CursorKind

file_template_hpp = """\
/*
 * file generated by di_ctor_traits: %(file)s
 */
#ifndef %(guard)s
#define %(guard)s

#include <boost/di/ctor.hpp>
%(includes)s

namespace boost {
namespace di {

%(ctor_traits)s

} // namespace di
} // namespace boost

#endif // %(guard)s

"""

if sys.version_info < (3, 0):
    import __builtin__
    def str(object, unused = None):
        return __builtin__.str(object)

    def bytes(object, unused = None):
        return __builtin__.bytes(object)

class ctor_trait:
    def __init__(self, name, args, args_len):
        self.name = name
        self.args = args
        self.args_len = args_len

    def to_string(self):
        ctor = []
        ctor.append(
            "template<>\nstruct ctor_traits< ::%(name)s >\n{\n    BOOST_DI_CTOR_TRAITS(%(args)s);\n};\n\n" % {
            'name' : self.name,
            'args' : self.args
        })

        return ''.join(ctor)

class ctor_traits_generator:
    def __get_ctors(self, node, ctors, class_decl = ""):
        name = str(node.displayname, self.encode)
        if node.kind == CursorKind.CONSTRUCTOR:
            args = name[len(node.spelling) + 1 : -1]
            args_len = len(list(node.get_arguments()))
            if args != "":
                found = False
                for i, item in enumerate(ctors):
                    if class_decl == item.name:
                        found = True
                        if args_len > item.args_len:
                            ctors[i] = ctor_trait(class_decl, args, args_len)
                        break
                if not found:
                    ctors.append(ctor_trait(class_decl, args, args_len))
        elif node.kind in [CursorKind.CLASS_DECL, CursorKind.STRUCT_DECL, CursorKind.NAMESPACE]:
            class_decl = class_decl == "" and name or class_decl + (name == "" and "" or "::") + name
            if class_decl.startswith(self.decl):
                [self.__get_ctors(c, ctors, class_decl) for c in node.get_children()]
        else:
            [self.__get_ctors(c, ctors, class_decl) for c in node.get_children()]

    def __generate_includes(self, includes):
        result = []
        for include in includes:
            result.append("#include \"%(include)s\"\n" % { 'include' : include })
        return ''.join(result)

    def __parse(self, args):
        tmp_file = b"~.hpp"
        return Index.create(excludeDecls = True).parse(
            path = tmp_file
          , args = args
          , unsaved_files = [(tmp_file, bytes(self.includes, self.encode))]
          , options = TranslationUnit.PARSE_SKIP_FUNCTION_BODIES | TranslationUnit.PARSE_INCOMPLETE
        )

    def __init__(self, files, args, decl, ctor_traits_file_hpp, file_template_hpp, encode = "utf-8"):
        self.decl = decl
        self.ctor_traits_file_hpp = ctor_traits_file_hpp
        self.file_template_hpp = file_template_hpp
        self.encode = encode
        self.includes = self.__generate_includes(files)
        self.cursor = self.__parse(args).cursor

    def generate(self):
        ctors = []
        self.__get_ctors(self.cursor, ctors)
        if len(ctors) > 0:
            with open(self.ctor_traits_file_hpp, 'w') as file:
                file.write(self.file_template_hpp % {
                    'file' : self.ctor_traits_file_hpp,
                    'guard' : self.ctor_traits_file_hpp.replace('.', '_').upper(),
                    'includes' : self.includes[:-1],
                    'ctor_traits' : ''.join(ctor.to_string() for ctor in ctors)[:-2]
                })
        return 0

def main(args):
    clang_args = None
    args_split = [i for i, arg in enumerate(args) if arg == "--"]
    if args_split:
        args, clang_args = args[:args_split[0]], args[args_split[0] + 1:]

    parser = OptionParser(usage="usage: %prog [options] files...")
    parser.add_option("-o", "--output", dest="output", default="di_ctor_traits.hpp", help="output file (default='di_ctor_traits.hpp')", metavar="OUTPUT")
    parser.add_option("-l", "--limit", dest="decl", default="", help="limit to constructors within declaration (default='')", metavar="LIMIT")
    (options, args) = parser.parse_args(args)

    if len(args) == 1:
        parser.error("at least one file has to be given")

    return ctor_traits_generator(
        files = args[1:],
        args = clang_args,
        decl = options.decl,
        ctor_traits_file_hpp = options.output,
        file_template_hpp = file_template_hpp
    ).generate()

if __name__ == "__main__":
    sys.exit(main(sys.argv))

